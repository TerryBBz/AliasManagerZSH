import fs from 'fs-extra';
import path from 'path';
import os from 'os';
import { fileURLToPath } from 'url';

export class DataManager {
  constructor() {
    this.homeDir = os.homedir();
    
    // D√©tecter le dossier du projet AliasManager
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    this.projectDir = path.resolve(__dirname, '..');
    
    // Utiliser le dossier data/ dans le projet
    this.configDir = path.join(this.projectDir, 'data');
    this.dataFile = path.join(this.configDir, 'aliases.json');
    this.aliasFile = path.join(this.configDir, 'aliases.sh');
    
    // Fichier de sync pour Git
    this.syncDir = path.join(this.projectDir, 'configs');
    this.syncFile = path.join(this.syncDir, 'sync.json');
  }

  async ensureConfigDir() {
    await fs.ensureDir(this.configDir);
    await fs.ensureDir(this.syncDir);
  }

  async loadData() {
    await this.ensureConfigDir();
    
    try {
      const data = await fs.readJSON(this.dataFile);
      return this.validateData(data);
    } catch (error) {
      // Si le fichier n'existe pas ou est invalide, cr√©er une structure par d√©faut
      return {
        groups: {
          default: {}
        }
      };
    }
  }

  async saveData(data) {
    await this.ensureConfigDir();
    await fs.writeJSON(this.dataFile, data, { spaces: 2 });
  }

  validateData(data) {
    // V√©rifier que la structure est correcte
    if (!data || typeof data !== 'object') {
      throw new Error('Format de donn√©es invalide');
    }

    if (!data.groups || typeof data.groups !== 'object') {
      data.groups = { default: {} };
    }

    // S'assurer qu'il y a toujours un groupe par d√©faut
    if (!data.groups.default) {
      data.groups.default = {};
    }

    // Valider chaque groupe et alias
    for (const [groupName, aliases] of Object.entries(data.groups)) {
      if (typeof aliases !== 'object') {
        data.groups[groupName] = {};
        continue;
      }

      for (const [aliasName, aliasData] of Object.entries(aliases)) {
        if (!aliasData || typeof aliasData !== 'object') {
          delete data.groups[groupName][aliasName];
          continue;
        }

        // S'assurer que chaque alias a les propri√©t√©s requises
        if (typeof aliasData.cmd !== 'string') {
          delete data.groups[groupName][aliasName];
          continue;
        }

        // D√©finir disabled par d√©faut √† false si absent
        if (typeof aliasData.disabled !== 'boolean') {
          aliasData.disabled = false;
        }
      }
    }

    return data;
  }

  async generateAliasFile(data) {
    const lines = ['# Generated by alias-manager', ''];

    for (const [groupName, aliases] of Object.entries(data.groups)) {
      const activeAliases = Object.entries(aliases)
        .filter(([, aliasData]) => !aliasData.disabled);

      if (activeAliases.length === 0) continue;

      lines.push(`# Group: ${groupName}`);
      
      for (const [aliasName, aliasData] of activeAliases) {
        const escapedCmd = this.escapeShellCommand(aliasData.cmd);
        lines.push(`alias ${aliasName}='${escapedCmd}'`);
      }
      
      lines.push('');
    }

    const content = lines.join('\n');
    await fs.writeFile(this.aliasFile, content, 'utf8');
  }

  escapeShellCommand(cmd) {
    // √âchapper les guillemets simples dans la commande
    return cmd.replace(/'/g, "'\"'\"'");
  }

  getDataFilePath() {
    return this.dataFile;
  }

  getAliasFilePath() {
    return this.aliasFile;
  }

  getConfigDir() {
    return this.configDir;
  }

  async importFromZshrc(zshrcPath = null) {
    const targetPath = zshrcPath || path.join(this.homeDir, '.zshrc');
    
    try {
      const content = await fs.readFile(targetPath, 'utf8');
      const lines = content.split('\n');
      const importedAliases = {};
      
      let currentGroup = 'imported';
      let currentSection = null;
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // D√©tecter les sections bas√©es sur les commentaires
        if (line.startsWith('# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ')) {
          const nextLine = lines[i + 1]?.trim();
          if (nextLine?.startsWith('#') && nextLine.includes('ALIAS') || nextLine.includes('RACCOURCIS') || nextLine.includes('MYSQL') || nextLine.includes('GIT') || nextLine.includes('UTILITAIRES')) {
            currentSection = this.extractSectionName(nextLine);
            currentGroup = currentSection || 'imported';
          }
        }
        
        // Parser les alias
        const aliasMatch = line.match(/^alias\s+([^=]+)=(.*)$/);
        if (aliasMatch) {
          const [, name, command] = aliasMatch;
          const cleanName = name.trim();
          const cleanCommand = this.cleanAliasCommand(command);
          const description = this.extractAliasDescription(lines, i);
          
          if (!importedAliases[currentGroup]) {
            importedAliases[currentGroup] = {};
          }
          
          importedAliases[currentGroup][cleanName] = {
            cmd: cleanCommand,
            description: description || `Alias import√© depuis .zshrc`,
            disabled: false
          };
        }
      }
      
      return importedAliases;
    } catch (error) {
      throw new Error(`Erreur lors de la lecture de ${targetPath}: ${error.message}`);
    }
  }

  extractSectionName(commentLine) {
    if (commentLine.includes('MYSQL')) return 'mysql';
    if (commentLine.includes('GIT')) return 'git';
    if (commentLine.includes('UTILITAIRES') || commentLine.includes('D√âVELOPPEMENT')) return 'utils';
    if (commentLine.includes('NAVIGATION')) return 'navigation';
    return 'imported';
  }

  cleanAliasCommand(command) {
    // Nettoyer les guillemets autour de la commande
    let cleaned = command.trim();
    if ((cleaned.startsWith('"') && cleaned.endsWith('"')) || 
        (cleaned.startsWith("'") && cleaned.endsWith("'"))) {
      cleaned = cleaned.slice(1, -1);
    }
    
    // Nettoyer les √©chappements de guillemets doubles dans les guillemets simples
    cleaned = cleaned.replace(/\\"/g, '"');
    
    return cleaned;
  }

  extractAliasDescription(lines, currentIndex) {
    // Chercher un commentaire inline apr√®s l'alias
    const currentLine = lines[currentIndex];
    const inlineComment = currentLine.match(/#\s*(.+)$/);
    if (inlineComment) {
      return inlineComment[1].trim();
    }
    
    // Chercher un commentaire sur la ligne pr√©c√©dente
    if (currentIndex > 0) {
      const prevLine = lines[currentIndex - 1].trim();
      if (prevLine.startsWith('#') && !prevLine.includes('‚îÄ')) {
        return prevLine.replace(/^#\s*/, '').trim();
      }
    }
    
    return null;
  }

  async mergeImportedData(importedAliases) {
    const currentData = await this.loadData();
    
    // Fusionner les groupes import√©s avec les donn√©es existantes
    for (const [groupName, aliases] of Object.entries(importedAliases)) {
      if (!currentData.groups[groupName]) {
        currentData.groups[groupName] = {};
      }
      
      // Ajouter les alias en √©vitant les doublons
      for (const [aliasName, aliasData] of Object.entries(aliases)) {
        if (!currentData.groups[groupName][aliasName]) {
          currentData.groups[groupName][aliasName] = aliasData;
        }
      }
    }
    
    await this.saveData(currentData);
    await this.generateAliasFile(currentData);
    
    return currentData;
  }

  async updateSyncFileAndGitPush(action, details) {
    try {
      // Mettre √† jour le fichier de sync avec les donn√©es actuelles
      const currentData = await this.loadData();
      await fs.writeJSON(this.syncFile, currentData, { spaces: 2 });

      // Auto-commit et push
      const { execSync } = await import('child_process');
      
      try {
        // Add le fichier de sync
        execSync(`git -C "${this.projectDir}" add configs/sync.json`, { stdio: 'pipe' });
        
        // Commit avec message descriptif
        const commitMessage = `${action}: ${details}`;
        execSync(`git -C "${this.projectDir}" commit -m "${commitMessage}"`, { stdio: 'pipe' });
        
        // Push
        execSync(`git -C "${this.projectDir}" push`, { stdio: 'pipe' });
        
        console.log(`üöÄ Synchronis√© avec Git: ${commitMessage}`);
        
      } catch (gitError) {
        console.log('‚ö†Ô∏è  Mise √† jour locale r√©ussie, mais √©chec Git:', gitError.message);
        console.log('üí° Vous devrez peut-√™tre faire un commit/push manuel.');
      }
      
    } catch (error) {
      console.log('‚ö†Ô∏è  Erreur lors de la synchronisation Git:', error.message);
    }
  }
}